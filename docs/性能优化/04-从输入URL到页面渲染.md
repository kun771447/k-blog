# 从输入 URL 到页面渲染

(1）浏览器接收到URL，到网络请求线程的开启。

(2)  一个完整的HTTP请求并的发出。
(3）服务器接收到请求并转到具体的处理后台。

(4）前后台之间的HTTP交互和涉及的缓存机制。

(5）浏览器接收到数据包后的关键渲染路径。

(6)  JS引擎的解析过程。



## 网络请求线程开启

浏览器接收到我们输入的 URL 到开启网络请求线程，这个阶段是在浏览器内部完要先来了解这里面涉及的一些概念。



- Protocol - 协议头
  
  - 说明浏览器如何处理的文件，常见的有卜FTP、Telnet等。

- Host - 主机域名 / IP 地址
  
  - 所访问资源在互联网址，主机域名或经过解析为IP地址。

- Port - 端口号
  
  - 请求程序和响应程序接用的标识

- Path - 目录路径
  
  - 请求的目录或文件名

- Query - 查询参数
  
  - 请求所传递的参数

- Fragment - 片段
  
  - 次级资源信息，通岸端路由或锚点



> URL结构: Protocol://Host:Port/Path?Query#Fragment
> 
> 例如 http://example.com/users/1?foo=bar#abc



首先是对 URL 的解析，解析 URL 后，如果是 HTTP 协议，则浏览器会新建一个网络请求线程去下载所需要明白这个过程需要了解进程和线程之间的区别，以及目前主流的多进程浏览器

### 进程与线程

简单来说，进程就是一个程序运行的实例，操作系统会为进程创建独立的内存，用来存放运行所需的代码和数据；而线程是进程的组成部分，每个进程至少有一个主线程及可能的若干子线程，这些线程由所属的进程进行启动和管理。由于多个线程可以共享操作系统为其所属的同一个进程所分配的资源，所以多线程的并行处理能有效提高程序的运行效率。



![](D:\系统默认\桌面\code\Project\k-blog\docs\public\性能优化\2023-03-06-18-06-51-image.png)



进程和线程之间的区别:

(1)   只要某个线程执行出错，将会导致整个进程崩溃。
(2）进程与进程之间相互隔离。这保证了当一个进程挂起或崩溃的情况发生时，并不会影响其他进程的正常运行，虽然每个进程只能访问系统分配给自己的资源，但可以通过IPC机制进行进程间通信。
(3）进程所占用的资源会在其关闭后由操作系统回收。即使进程中存在某个线程产生的内存泄漏，当进程退出时，相关的内存资源也会被回收。
(4）线程之间可以共享所属进程的数据。

### 单进程浏览器

在熟悉了进程和线程之间的区别后，我们在此基础上通过了解浏览器架构模型的演变，来看看网络请求线程的开启处在怎样的位置。


说到底浏览器也只是一个运行在操作系统上的程序，那么它的运行单位就是进程，而早在2008年谷歌发布Chrome多进程浏览器之前，市面上几乎所有浏览器都是单进程的，它们将所有功能模块都运行在同一个进程中，其架构示意图如下图所示。



![](D:\系统默认\桌面\code\Project\k-blog\docs\public\性能优化\2023-03-06-18-12-52-image.png)

单进程浏览器在以下方面有着较为明显的隐患



- 流畅性:首先是页面内存泄漏，浏览器内核通常非常复杂，单进程浏览器打开再关闭一个页面的操作，通常会有一些内存不能完全回收，这样随着使用时间延长，占用的内存会越来越多，从而引起浏览器运行变慢;其次由于很多模块运行在同一个线程中，如JS引擎、页面渲染及插件等，那么执行某个循环任务的模块就会阻塞其他模块的任务执行，这样难免会有卡顿的现象发生。

- 安全性:由于插件的存在，不免其中有些恶意脚本会利用浏览器漏洞来获取系统权限，进行引发安全问题的行为。

- 稳定性:由于所有模块都运行在同一个进程中，对于稍复杂的JS代码，如果页面渲染引擎崩溃，就会导致整个浏览器崩溃。同样，各种不稳定的第三方插件，也是导致浏览器崩溃的隐患。



### 多进程浏览器

出于对单进程浏览器存在问题的优化，Chrome推出了多进程浏览器架构，浏览器把原先单进程内功能相对独立的模块抽离为单个进程处理对应的任务，主要分为以下几种进程。

![](D:\系统默认\桌面\code\Project\k-blog\docs\public\性能优化\2023-03-06-18-15-30-image.png)

(1）**浏览器主进程**: 一个浏览器只有一个主进程，负责如菜单栏、标题栏等界面显示，文件访问，前进后退，以及子进程管理等。
(2)    **GPU进程**: GPU(图形处理单元）最初是为了实现3D的CSS效果而引入的，后来随着网页及浏览器在界面中的使用需求越来越普遍，Chrome便在架构中加入了GPU进程。
(3）**插件进程**: 主进程会为每个加入浏览器的插件开辟独立的子进程，由于进程间所分配的运行资源相对独立，所以即便某个插件进程意外崩溃，也不至于对浏览器和页面造成影响。另外，出于对安全因素的考虑，这里采用了沙箱模式（即上图中虚线所标出的进程)，在沙箱中运行的程序受到一些限制:不能读取敏感位置的数据，也不能在硬盘上写入数据。这样即使插件运行了恶意脚本，也无法获取系统权限。
(4）**网络进程**: 负责页面的网络资源加载，之前属于浏览器主进程中的一个模块，最近才独立出来。

(5）**渲染进程**: 也称为浏览器内核，其默认会为**每个标签窗口页开辟一个独立的渲染进程**，负责将HTML.'cSS和JavaScript等资源转为可交互的页面，其中包含多个子线程，即JS引擎线程、GUI渲染线程、事件触发线程、定时触发器线程、异步HTTP请求线程等。当打开一个标签页输入URL后，所发起的网络请求就是从这个进程开始的。另外，出于对安全性的考虑，渲染进程也被放入沙箱中。



## 建立 HTTP 请求

这个阶段的主要工作分为两部分:DNS解析和通信链路的建立。


简单说就是:

- 首先发起请求的客户端浏览器要明确知道所要访问的服务器地址

- 然后建立通往该服务器地址的路径



### DNS 解析



![](D:\系统默认\桌面\code\Project\k-blog\docs\public\性能优化\2023-03-06-18-22-32-image.png)



### 网络模型

![](D:\系统默认\桌面\code\Project\k-blog\docs\public\性能优化\2023-03-06-18-27-32-image.png)



- 应用层
  
  - 负责给应用程序提供接口，使其可l络服务，HTTP 协议就位于该层

- 表示层
  
  - 负责数据的编码与解码，加密和解和解压缩

- 会话层
  
  - 负责协调系统之间的通信过程

- 传输层
  
  - 负责端到端连接的建立，使报文能网络层和应用层之间进行传输。TCP/UDP协议

- 网络层     
  
  - 主要功能是提供端到端的数据传输服务，它通过路由选择将数据报从源节点传输到目的节点

- 数据链路层
  
  - 主要负责将网络层提供的数据报转换为物理层可以识别的帧，并发送到网络媒介上

- 物理层
  
  - 主要作用是将数字信号转换为模拟信号，以便在网络媒介（如铜线、光纤或无线电波）中传输。在数字化的网络中，物理层将比特流转换为物理信号，并在网络媒介中传输这些信号。
  
  - 负责将数字信号转换为可在网络媒介中传输的模拟信号，确保数据的准确传输。



### TCP 连接

三次握手 建立连接

四次挥手 断开连接 

## 前后端的交互

当TCP连接建立好之后，便可通过HTTP等协议进行前后端的通信，但在实际的中，并非浏览器与确定IP地址的服务器之间直接通信，往往会在中间加入反向代器。

### 反向代理服务器

反向代理服务器（Reverse Proxy Server）是一个位于服务器端的代理服务器，它接收客户端请求，并将请求转发给后端服务器，从而隐藏了真实的服务器地址和细节，让客户端看到的只是反向代理服务器的地址和响应。反向代理服务器通常用于实现负载均衡、安全性、缓存等功能。

反向代理服务器的主要作用包括：

1. 负载均衡：反向代理服务器可以将客户端的请求分摊到多个后端服务器上，从而实现负载均衡，提高系统的并发处理能力。

2. 缓存加速：反向代理服务器可以将客户端的请求缓存到自己的缓存中，当有相同的请求时，直接从缓存中返回结果，从而提高系统的响应速度和性能。

3. 安全性：反向代理服务器可以对客户端的请求进行一定的安全性处理，如防止DDoS攻击、XSS攻击、SQL注入等。

4. 稳定性：反向代理服务器可以隐藏后端服务器的真实地址，从而提高系统的稳定性和安全性，避免直接暴露服务器并避免受到攻击。

![](D:\系统默认\桌面\code\Project\k-blog\docs\public\性能优化\2023-03-06-18-55-58-image.png)

反向代理服务器根据客户的请求，从后端服务器上获取资源后提供给客户端。反向代理服务器通常的作用如下:

- 负载均衡。

- 安全防火墙。

- 加密及SSL加速。

- 数据压缩。

- 解决跨域。

- 对静态资源缓存。



### 后端处理流程

经反向代理收到请求后，具体的服务器后台处理流程大致如下。
(1）首先会有一层统一的验证环节，如跨域验证、安全校验拦截等。如果发现是则的请求，则直接返回相应的拒绝报文。
(2）通过验证后才会进入具体的后台程序代码执行阶段，如具体的计算、数据库读取等

(3）完成计算后，后台会以一个HTTP响应数据包的形式发送回请求的前端，结束请求


### HTTP 相关协议特性

HTTP是建立在传输层TCP协议之上的应用层协议，在TCP层面上存在长连接和区别。所谓长连接，就是在客户端与服务器端建立的TCP连接上，可以连续发送包，但需要双方发送心跳检查包来维持这个连接。


短连接就是当客户端需要向服务器端发送请求时，会在网络层IP协议之上建立一接，当请求发送并收到响应后，则断开此连接。根据前面关于TCP连接建立过程我们知道如果这个过程频繁发生，就是个很大的性能耗费，所以从 HTTP的1.0 片于连接的优化一直在进行。


在HTTP 1.0时，默认使用短连接，浏览器的每一次HTTP操作就会建立一个连书束则断开连接。



在HTTP 1.1时，默认使用长连接，在此情况下，当一个网页的打开操作完成时，立用于传输HTTP的TCP连接并不会断开关闭，客户端后续的请求操作便会继续已经建立的连接。如果我们对浏览器的开发者工具留心，在查看请求头时会发现-Connection: keep-alive。长连接并非永久保持，它有一个持续时间，可在行配置。

而在HTTP2.0到来之前，每一个资源的请求都需要开启一个TCP连接，由于TC并发数的限制，这样的结果就是，当请求的资源变多时，速度性能就会明显下降。常会采用的优化策略包括，将静态资源的请求进行多域名拆分，对于小图标或图片等。



在HTTP 2.0之后，便可以在一个TCP连接上请求多个资源，分割成更小的帧请:性能便会明显上升，所以之前针对 HTTP 1.1 限制的优化方案也就不再需要了。

HTTP 2.0除了一个连接可请求多个资源这种多路复用的特性，还有如下一些新特
(1）二进制分帧:在应用层和传输层之间，新加入了一个二进制分帧层，以实现高吞吐量。
(2）服务器端推送:以往是一个请求带来一个响应，现在服务器可以向客户端的发出多个响应，这样便可以实现服务器端主动向客户端推送的功能。
(3）设置请求优先级:服务器会根据请求所设置的优先级，来决定需要多少资源请求。
(4)  HTTP头部压缩:减少报文传输体积。



### 浏览器缓存

在基于HTTP的前后端交互过程中，使用缓仔可以使性能得到显著的提升。具体的缓存分为两种: 强缓存和协商缓存。



强缓存就是当浏览器判断出本地缓存未过期时，直接读取本地缓存，无须发起HTTP 请求此时状态为: 200 from cache。在HTTP 1.1版本后通过头部的 cache-control:max-age属性值规定的过期时长来判断缓存是否过期失效，这比之前使用 expire 的服务器过期时间更准确而且安全。


协商缓存则需要浏览器向服务器发起HTTP请求，来判断浏览器本地缓存的文件改，若未修改则从缓存中读取，此时的状态码为: 304。



## 关键渲染路径

### 构建对象模型

首先浏览器会通过解析HTML和CSS文件，来构建DOM(文档对象模型）和CSSOM(层叠样式表对象模型），为便于理解，我们以如下HTML内容文件为例，来观察文档对象模型的构建过程。



浏览器接收读取到的HTML文件，其实是文件根据指定编码（UTF-8)的原始字节，形如3C 62 6F 79 3E 65 6C 6F 2c 20 73 7...。首先需要将字节转换成字符，即原本的代码字符串，接着再将字符串转化为W3C标准规定的令牌结构，所谓令牌就是HTML中不同标签代表不同含义的一组规则结构。然后经过词法分析将令牌转化成定义了属性和规则值的对象，最后将这些标签节点根据HTML表示的父子关系，连接成树形结构，如下图所示。



![](D:\系统默认\桌面\code\Project\k-blog\docs\public\性能优化\2023-03-06-19-18-35-image.png)

DOM树表示文档标记的属性和关系，但未包含其中各元素经过渲染后的外观呈现，这便是接下来CSSOM的职责了，与将HTML文件解析为文档对象模型的过程类似，CSS文件也会首先经历从字节到字符串，然后令牌化及词法分析后构建为层叠样式表对象模型。假设CSS文件内容如下:



最后构建 CSSOM 树如图所示

![](D:\系统默认\桌面\code\Project\k-blog\docs\public\性能优化\2023-03-06-19-20-57-image.png)

这两个对象模型的构建过程是会花费时间的，可以通过打开Chrome浏览器的开发者工具的性能选项卡，查看到对应过程的耗时情况，如图所示。



### 渲染绘制

当完成文档对象模型和层叠样式表对象模型的构建后，所得到的其实是描述最终渲染页面两个不同方面信息的对象:一个是展示的文档内容，另一个是文档对象对应的样式规则，接下来就需要将两个对象模型合并为渲染树，渲染树中只包含渲染可见的节点，该HTML文档最终生成的渲染树如图所示。



![](D:\系统默认\桌面\code\Project\k-blog\docs\public\性能优化\2023-03-06-19-23-53-image.png)

渲染绘制的步骤大致如下。
(1)   从所生成DOM树的根节点开始向下遍历每个子节点，忽略所有不可见的节点（脚本标记不可见、CSS隐藏不可见)，因为不可见的节点不会出现在渲染树中。
(2）在CSSOM中为每个可见的子节点找到对应的规则并
应用。
(3）布局阶段，根据所得到的渲染树，计算它们在设备视图中的具体位置和大小，这一步输出的是一个“盒模型”。
(4）绘制阶段，将每个节点的具体绘制方式转化为屏幕上的实际像素。
此处所举的例子较为简单，读者要明白执行构建渲染树、布局及绘制过程所需要的时间取决于实际文档的大小。文档越大，浏览器需要处理的任务就越多，样式也复杂，绘制需要的时间就越长，所以关键渲染路径执行快慢，将直接影响首屏加载时间的性能指标。



当首屏渲染完成后，用户在和网站的交互过程中，有可能通过JavaScript代码提供的用户操作接口更改渲染树的结构，一旦DOM结构发生改变，这个渲染过程就会重新执行一遍。可见对于关键渲染路径的优化影响的不仅是首屏性能，还有交互性能。
本节仅对首屏渲染过程进行了简要描述，其中细节性的优化方案，将会在后续章节中展开介绍。
