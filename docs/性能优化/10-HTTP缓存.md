## HTTP 缓存

在任何一个前端项目中，访问服务器获取数据都是很常见的事情，但是如果相同的数据被重复请求了不止一次，那么多余的请求次数必然会浪费网络带宽，以及延迟浏览器渲染所要处理的内容，从而影响用户的使用体验。如果用户使用的是按量计费的方式访问网络，那么多余的请求还会隐性地增加用户的网络流量资费。因此考虑使用缓存技术对已获取的资源进行重用，是一种提升网站性能与用户体验的有效策略。


缓存的原理是在首次请求后保存一份请求资源的响应副本，当用户再次发起相同请求后，如果判断缓存命中则拦截请求，将之前存储的响应副本返回给用户，从而避免重新向服务器发起资源请求。



缓存的技术种类有很多，比如代理缓存、浏览器缓存、网关缓存、负载均衡器及内容分发网络等，它们大致可以分为两类:共享缓存和私有缓存。共享缓存指的是缓存内容可被多个用户使用，如公司内部架设的Web代理;私有缓存指的是只能单独被用户使用的缓存，如浏览器缓存。



HTTP缓存应该算是前端开发中最常接触的缓存机制之一，它又可细分为强制缓存与协商缓存，二者最大的区别在于判断缓存命中时，浏览器是否需要向服务器端进行询问以协商缓存的相关信息，进而判断是否需要就响应内容进行重新请求。下面就来具体看HTTP缓存的具体机制及缓存的决策策略。



## 强制缓存


expires 依赖本地时间, 本地时间可以改

cache-control



### no-cache 和 public

no-cache 强制使用协商缓存

no-store 禁用任何缓存策略



no-cache 和 no-store 不能同时设置



### private 和 public

**private**和**public**也是**cache-control**的一组互斥属性值，它们用以明确响应资源是否可被代理服务器进行缓存。



- 若资源响应头中的 **cache-control** 字段设置了 **public** 属性值，则表示响应资源既可以被浏览器缓存，又可以被代理服务器缓存。

- **private** 则限制了响应资源只能被浏览器缓存，若未显式指定则默认值为 **private**



对于应用程序中不会改变的文件，你通常可以在发送响应头前添加积极缓存。这包括例如由应用程序提供的静态文件，例如图像，cSS文件和JavaScript文件。



### s-maxage

maxage 存在的意义，它表示缓存在代理服务器中的过期时长，且仅当设置了public属性值时才有效。



## 协商缓存

### last-modifed

![](D:\系统默认\桌面\code\Project\k-blog\docs\public\性能优化\2023-03-10-10-26-07-image.png)

通过 **last-modified** 所实现的协商缓存能够满足大部分的使用场景，但也存在两个比较明显的缺陷:



- 首先它只是根据资源最后的修改时间戳进行判断的，虽然请求的文件资源进行了编辑，但内容并没有发生任何变化，时间戳也会更新，从而导致协商缓存时关于有效性的判断验证为失效，需要重新进行完整的资源请求。这无疑会造成网络带宽资源的浪费，以及延长用户获取到目标资源的时间

- 其次标识文件资源修改的时间戳单位是秒，如果文件修改的速度非常快，假设在几百毫秒内完成，那么上述通过时间戳的方式来验证缓存的有效性，是无法识别出该次文件资源的更新的。



其实造成上述两种缺陷的原因相同，就是服务器无法仅依据资源修改的时间戳来识别出真正的更新，进而导致重新发起了请求，该重新请求却使用了缓存的Bug场景。



### Etag

为了弥补通过时间戳判断的不足，从HTTP1.1规范开始新增了一个ETag的头信息，即实体标签(Entity Tag)。


其内容主要是服务器为不同资源进行哈希运算所生成的一个字符串，该字符串类似于文件指纹，只要文件内容编码存在差异，对应的ETag标签值就会不同，因此可以使用ETag 对文件资源进行更精准的变化感知。下面我们来看一个使用ETag 进行协商缓存图片资源的示例，首次请求后的部分响应头



![](D:\系统默认\桌面\code\Project\k-blog\docs\public\性能优化\2023-03-10-10-31-18-image.png)



### ETag 的不足

不像强制缓存中 cache-control 可以完全替代 expires 的功能，在协商缓存中，ETag 并非 last-modified 的替代方案而是一种补充方案，因为它依旧存在一些弊端。


- —方面服务器对于生成文件资源的 ETag 需要付出额外的计算开销，如果资源的尺寸较大，数量较多且修改比较频繁，那么生成 ETag 的过程就会影响服务器的性能

- 另一方面ETag字段值的生成分为强验证和弱验证，强验证根据资源内容进行生成，能够保证每个字节都相同;弱验证则根据资源的部分属性值来生成，生成速度快但无法确保每个字节都相同，并且在服务器集群场景下，也会因为不够准确而降低协商缓存有效性验证的成功率，所以恰当的方式是根据具体的资源使用场景选择恰当的缓存校验方式。



## 缓存策略

**1、拆分源码，分包加载**


对大型的前端应用迭代开发来说，其代码量通常很大，如果发生修改的部分集中在几个重要模块中，那么进行全量的代码更新显然会比较冗余，因此我们可以考虑在代码构建过程中，按照模块拆分将其打包成多个单独的文件。这样在每次修改后的更新提取时，仅需拉取发生修改的模块代码包，从而大大降低了需要下载的内容大小。


**2、预估资源的缓存时效**


根据不同资源的不同需求特点，规划相应的缓存更新时效，为强制缓存指定合适的max-age取值，为协商缓存提供验证更新的ETag 实体标签。



**3、控制中间代理的缓存**


凡是会涉及用户隐私信息的尽量避免中间代理的缓存，如果对所有用户响应相同的资源，则可以考虑让中间代理也进行缓存。


**4、避免网址的冗余**


缓存是根据请求资源的URL进行的，不同的资源会有不同的URL，所以尽量不要将相同的资源设置为不同的URL。



**5、规划缓存的层次结构**



参考缓存决策中介绍的示例，不仅是请求的资源类型，文件资源的层次结构也会对制定缓存策略有一定影响，我们应当综合考虑。
