# 拥塞控制

- 慢启动

- 拥塞控制

- 快速重传

- 快速恢复

![](D:\系统默认\桌面\code\Project\k-blog\docs\public\tcp\2023-02-14-15-13-28-image.png)

由于 TCP 协议向应用层提供不定长的字节流发送方法，使的 TCP 有意愿去占满整个带宽，当网络中多个 TCP 连接同时试图建立整个带宽时，就可能发生恶心拥塞事件，TCP 拥塞控制算法就降低网络中的拥塞，提升所有 TCP 的连接速度

## 拥塞控制历史

- 以丢包作为依据
  
  - New Reno: RFC6582.BlC: Linux2.6.8-2.6.18
  
  - CUBIC (RFC8312) : Linux2.6.19

- 以探测带宽作为依据
  
  - BBR: Linux4.9

## 慢启动

- 拥塞窗口cwnd(congestion window)
  
  - 通告窗口(接收窗口) rwnd (receiver`s advertised window)
  
  - 发送窗口 swnd = min(cwnd, rwnd)

- 每收到一个 ACK，cwnd 扩充为收到 ACK 的一倍

![](D:\系统默认\桌面\code\Project\k-blog\docs\public\tcp\2023-02-14-15-56-13-image.png)

## 慢启动的初始窗口

- 慢启动初始窗口IW(Initial Window)的变迁
  
  - 1SMSS: RFC2001 (1997)
  
  - 2 - 4 SMSS: RFC2414 (1998)
    
    - IW = min(4 * SMSS, max (2 * SMSS, 4380bytes))
  
  - 10 SMSS: RFC6928 (2013)
    
    - IW = min(10 * MSS, max(2 * MSS, 14600))
    
    - gogle 发现大多数网页都在 10 个 MSS



## 拥塞避免

![](D:\系统默认\桌面\code\Project\k-blog\docs\public\tcp\2023-02-14-20-04-33-image.png)

在没有拥塞避免算法时，我们的慢启动时成线性增长，当出现丢包，丢包数量就可能非常大



比如上次 cwnd = 20，而我们超过 28 就开始丢包，下次收到 ack, cwnd = 40, 这样就会丢 12    个



- **拥塞避免定义了慢启动阈值 ssthresh(slow start threshold)**
  
  - 达到 ssthresh 后，以线性方式增加 cwnd
  
  - cwnd += SMSS * SMSS / cwnd



再出现**丢包**的情况就将 **慢启动阈值降低为拥塞窗口的一半，再将拥塞定义为一个比较小的值** 



## 慢启动和拥塞避免

![](D:\系统默认\桌面\code\Project\k-blog\docs\public\tcp\2023-02-14-20-29-05-image.png)

## 快速重传

当出现丢包时我们会重新执行慢启动，传输效率也会大幅度下降，当出现场景不是很严重的时候，我们可以采用快速重传和快速恢复

### 为何会接收到失序数据段？

### ![](D:\系统默认\桌面\code\Project\k-blog\docs\public\tcp\2023-02-14-20-34-38-image.png)

- 若报文丢失，后续的报文到达我们接收端，将会发送连续的失序ACK段确认丢失的报文段
  
  - 拥塞控制针对丢包情况

- 若网络路径与设备导致数据段失序，将会产生少量的失序ACK段

- 若报文重复，将会产生少量的失序ACK段

## 快速重传（RFC2581）

- 接收方:
  
  - 当接收到一个失序数据段时，立刻发送它所期待的缺口ACK序列号
  
  - 当接收到填充失序缺口的数据段时，立刻发送它所期待的下一个ACK序列号

- 发送方
  
  - 当接收到 4 个相同的失序 ACK段时，不再等待重传定时器的触发，立刻基于快速重传机制重发报文段

![](D:\系统默认\桌面\code\Project\k-blog\docs\public\tcp\2023-02-14-20-42-37-image.png)



### 超时不会启动快速重传

![](D:\系统默认\桌面\code\Project\k-blog\docs\public\tcp\2023-02-14-20-46-26-image.png)

如上图 ack9  没有重复发送 达到 4 次，所以不启动

## 

### 快速重传下一定要进入慢启动吗？

- 收到重复的 ack，意味着网络仍在流动
  
  - 慢启动会突然减少数据流

## 快速恢复 (RFC2581)

- **启动快速重传且正常未失序ACK段到达前(比如上图 pkt9)，启动快速恢复**
  
  - 将 ssthresh 设置为当前拥塞窗口 cwnd 的一半，设当前 cwnd 为 ssthresh 加上3 * MSS
  
  - 每收到一个重复 ACK , cwnd 增加 1 个 MSS
  
  - 当新数据 ACK 到达后，设置 cwnd 为 ssthresh

![](D:\系统默认\桌面\code\Project\k-blog\docs\public\tcp\2023-02-14-20-53-39-image.png)
