import{_ as e,c as i,o as l,a as t}from"./app.2acdff0e.js";const a="/k-blog/tcp/06/2023-02-22-10-51-32-image.png",r="/k-blog/tcp/06/2023-02-22-11-04-20-image.png",p="/k-blog/tcp/06/2023-02-22-11-06-35-image.png",c="/k-blog/tcp/06/2023-02-22-11-11-21-image.png",n="/k-blog/tcp/06/2023-02-22-11-23-10-image.png",s="/k-blog/tcp/06/2023-02-22-11-27-56-image.png",h="/k-blog/tcp/06/2023-02-22-11-30-55-image.png",d="/k-blog/tcp/06/2023-02-22-11-55-00-image.png",o="/k-blog/tcp/06/2023-02-22-12-04-02-image.png",g="/k-blog/tcp/06/2023-02-22-12-04-46-image.png",u="/k-blog/tcp/06/2023-02-22-12-13-12-image.png",m="/k-blog/tcp/06/2023-02-22-12-15-23-image.png",_="/k-blog/tcp/06/2023-02-22-12-17-11-image.png",k="/k-blog/tcp/06/2023-02-22-12-17-38-image.png",v="/k-blog/tcp/06/2023-02-22-12-18-03-image.png",E=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"关闭连接过程","slug":"关闭连接过程","link":"#关闭连接过程","children":[{"level":3,"title":"关闭连接：防止数据丢失；与应用层交互","slug":"关闭连接-防止数据丢失-与应用层交互","link":"#关闭连接-防止数据丢失-与应用层交互","children":[]},{"level":3,"title":"两端同时关闭连接","slug":"两端同时关闭连接","link":"#两端同时关闭连接","children":[]},{"level":3,"title":"TCP 状态机","slug":"tcp-状态机","link":"#tcp-状态机","children":[]}]},{"level":2,"title":"优化关闭连接时 TIME-WAIT 状态","slug":"优化关闭连接时-time-wait-状态","link":"#优化关闭连接时-time-wait-状态","children":[{"level":3,"title":"TIME-WAIT 状态过短或者不存在会怎么样？","slug":"time-wait-状态过短或者不存在会怎么样","link":"#time-wait-状态过短或者不存在会怎么样","children":[]},{"level":3,"title":"Linux 下 TIME-WAIT 优化：tcp_tw_reuse","slug":"linux-下-time-wait-优化-tcp-tw-reuse","link":"#linux-下-time-wait-优化-tcp-tw-reuse","children":[]},{"level":3,"title":"TIME-WAIT 优化","slug":"time-wait-优化","link":"#time-wait-优化","children":[]},{"level":3,"title":"RST 复位报文","slug":"rst-复位报文","link":"#rst-复位报文","children":[]}]},{"level":2,"title":"keepalive、校验和及带外数据","slug":"keepalive、校验和及带外数据","link":"#keepalive、校验和及带外数据","children":[{"level":3,"title":"TCP 的 Keep-Alive 功能","slug":"tcp-的-keep-alive-功能","link":"#tcp-的-keep-alive-功能","children":[]},{"level":3,"title":"违反分层原则校验和","slug":"违反分层原则校验和","link":"#违反分层原则校验和","children":[]},{"level":3,"title":"PSH 调整应用 TCP 发送数据的时机","slug":"psh-调整应用-tcp-发送数据的时机","link":"#psh-调整应用-tcp-发送数据的时机","children":[]},{"level":3,"title":"URG: 紧急处理数据","slug":"urg-紧急处理数据","link":"#urg-紧急处理数据","children":[]},{"level":3,"title":"面向字节流的 TCP 连接如何多路复用","slug":"面向字节流的-tcp-连接如何多路复用","link":"#面向字节流的-tcp-连接如何多路复用","children":[]},{"level":3,"title":"Multiplexing多路复用","slug":"multiplexing多路复用","link":"#multiplexing多路复用","children":[]},{"level":3,"title":"非阻塞socket: 同时处理多个TCP连接","slug":"非阻塞socket-同时处理多个tcp连接","link":"#非阻塞socket-同时处理多个tcp连接","children":[]},{"level":3,"title":"epoll + 非阻塞 scoket","slug":"epoll-非阻塞-scoket","link":"#epoll-非阻塞-scoket","children":[]},{"level":3,"title":"epoll 为什么高效","slug":"epoll-为什么高效","link":"#epoll-为什么高效","children":[]},{"level":3,"title":"非阻塞+epoll+同步编程=协程","slug":"非阻塞-epoll-同步编程-协程","link":"#非阻塞-epoll-同步编程-协程","children":[]}]}],"relativePath":"tcp/06-四次挥手.md"}'),T={name:"tcp/06-四次挥手.md"},x=t('<h2 id="关闭连接过程" tabindex="-1">关闭连接过程 <a class="header-anchor" href="#关闭连接过程" aria-hidden="true">#</a></h2><h3 id="关闭连接-防止数据丢失-与应用层交互" tabindex="-1">关闭连接：防止数据丢失；与应用层交互 <a class="header-anchor" href="#关闭连接-防止数据丢失-与应用层交互" aria-hidden="true">#</a></h3><ul><li><p>FIN：结束</p></li><li><p>ACK：确认</p></li></ul><img src="'+a+'"><h3 id="两端同时关闭连接" tabindex="-1">两端同时关闭连接 <a class="header-anchor" href="#两端同时关闭连接" aria-hidden="true">#</a></h3><img src="'+r+'"><h3 id="tcp-状态机" tabindex="-1">TCP 状态机 <a class="header-anchor" href="#tcp-状态机" aria-hidden="true">#</a></h3><img src="'+p+'"><h2 id="优化关闭连接时-time-wait-状态" tabindex="-1">优化关闭连接时 TIME-WAIT 状态 <a class="header-anchor" href="#优化关闭连接时-time-wait-状态" aria-hidden="true">#</a></h2><h3 id="time-wait-状态过短或者不存在会怎么样" tabindex="-1">TIME-WAIT 状态过短或者不存在会怎么样？ <a class="header-anchor" href="#time-wait-状态过短或者不存在会怎么样" aria-hidden="true">#</a></h3><img src="'+c+'"><p>假设我们 TIME-WAIT 状态，接收到 FIN 后就直接关闭，如果有其他设备复用了这个连接，上个的连接的包在网络中被延迟了，在新的连接中的接收方，就会造成数据错乱的影响</p><h3 id="linux-下-time-wait-优化-tcp-tw-reuse" tabindex="-1">Linux 下 TIME-WAIT 优化：tcp_tw_reuse <a class="header-anchor" href="#linux-下-time-wait-优化-tcp-tw-reuse" aria-hidden="true">#</a></h3><img src="'+n+'"><h3 id="time-wait-优化" tabindex="-1">TIME-WAIT 优化 <a class="header-anchor" href="#time-wait-优化" aria-hidden="true">#</a></h3><img src="'+s+'"><h3 id="rst-复位报文" tabindex="-1">RST 复位报文 <a class="header-anchor" href="#rst-复位报文" aria-hidden="true">#</a></h3><img src="'+h+'"><p>在遇到异常情况下，可以通过 RST 绕开 4 次握手，例如：进程突然关闭</p><h2 id="keepalive、校验和及带外数据" tabindex="-1">keepalive、校验和及带外数据 <a class="header-anchor" href="#keepalive、校验和及带外数据" aria-hidden="true">#</a></h2><h3 id="tcp-的-keep-alive-功能" tabindex="-1">TCP 的 Keep-Alive 功能 <a class="header-anchor" href="#tcp-的-keep-alive-功能" aria-hidden="true">#</a></h3><ul><li><p>Linux 的 tcp keepalive</p><ul><li><p>发送心跳周期</p><ul><li><p>Linux: net.ipv4.tcp_keepalive_time = 7200(s)</p></li><li><p>在两个小时没有收发任何数据的情况下，开启 Keep-Alive 检测功能</p></li><li><p>Keep-Alive 检测功能会发送多个探测包</p></li></ul></li><li><p>探测包发送间隔</p><ul><li>net.ipv4.tcp_keepalive_intvl = 75(s)</li></ul></li><li><p>探测包重试次数</p><ul><li><p>net.ipv4.tcp_keepalive_probes = 9</p></li><li><p>在达到重试次数后没有收到应答，关闭 TCP 连接</p></li></ul></li></ul></li></ul><h3 id="违反分层原则校验和" tabindex="-1">违反分层原则校验和 <a class="header-anchor" href="#违反分层原则校验和" aria-hidden="true">#</a></h3><ul><li><p>对关键头部数据（12字节)+TCP数据执行校验和计算</p><ul><li>计算中假定checksum为0</li></ul></li></ul><img src="'+d+'"><h3 id="psh-调整应用-tcp-发送数据的时机" tabindex="-1">PSH 调整应用 TCP 发送数据的时机 <a class="header-anchor" href="#psh-调整应用-tcp-发送数据的时机" aria-hidden="true">#</a></h3><p>例如：我们调用了一个 read 方法，获取一个 10 MB 的数据，这个数据会被拆分成很多个 segment，每个 segment 不能大于 MSS，在最后一个报文就会自动在 TCP 头部 PSH 置为一，缓冲区中的内容交给应用进程去处理，而不要等待缓冲区必须达到多少字节去处理</p><img src="'+o+'"><h3 id="urg-紧急处理数据" tabindex="-1">URG: 紧急处理数据 <a class="header-anchor" href="#urg-紧急处理数据" aria-hidden="true">#</a></h3><ul><li><p>紧急标志位，在接受方收到后会优先处理，不管缓存区是否有未处理完的数据</p></li><li><p>想要终止行为，下载大文件想要取消</p></li></ul><img src="'+g+'"><h3 id="面向字节流的-tcp-连接如何多路复用" tabindex="-1">面向字节流的 TCP 连接如何多路复用 <a class="header-anchor" href="#面向字节流的-tcp-连接如何多路复用" aria-hidden="true">#</a></h3><h3 id="multiplexing多路复用" tabindex="-1">Multiplexing多路复用 <a class="header-anchor" href="#multiplexing多路复用" aria-hidden="true">#</a></h3><ul><li>在一个信道上传输多路信号或数据流的过程和技术</li></ul><img src="'+u+'"><h3 id="非阻塞socket-同时处理多个tcp连接" tabindex="-1">非阻塞socket: 同时处理多个TCP连接 <a class="header-anchor" href="#非阻塞socket-同时处理多个tcp连接" aria-hidden="true">#</a></h3><img src="'+m+'"><h3 id="epoll-非阻塞-scoket" tabindex="-1">epoll + 非阻塞 scoket <a class="header-anchor" href="#epoll-非阻塞-scoket" aria-hidden="true">#</a></h3><img src="'+_+'"><h3 id="epoll-为什么高效" tabindex="-1">epoll 为什么高效 <a class="header-anchor" href="#epoll-为什么高效" aria-hidden="true">#</a></h3><img src="'+k+'"><h3 id="非阻塞-epoll-同步编程-协程" tabindex="-1">非阻塞+epoll+同步编程=协程 <a class="header-anchor" href="#非阻塞-epoll-同步编程-协程" aria-hidden="true">#</a></h3><img src="'+v+'">',43),b=[x];function f(w,I,P,A,C,M){return l(),i("div",null,b)}const W=e(T,[["render",f]]);export{E as __pageData,W as default};
