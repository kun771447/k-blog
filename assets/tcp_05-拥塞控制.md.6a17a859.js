import{_ as i,c as l,o as e,a}from"./app.2acdff0e.js";const n="/k-blog/tcp/05/2023-02-14-15-13-28-image.png",r="/k-blog/tcp/05/2023-02-14-15-56-13-image.png",t="/k-blog/tcp/05/2023-02-14-20-04-33-image.png",c="/k-blog/tcp/05/2023-02-14-20-29-05-image.png",p="/k-blog/tcp/05/2023-02-14-20-34-38-image.png",s="/k-blog/tcp/05/2023-02-14-20-42-37-image.png",d="/k-blog/tcp/05/2023-02-14-20-46-26-image.png",h="/k-blog/tcp/05/2023-02-14-20-53-39-image.png",o="/k-blog/tcp/05/2023-02-19-14-50-18-image.png",g="/k-blog/tcp/05/2023-02-19-15-09-18-image.png",u="/k-blog/tcp/05/2023-02-19-15-10-39-image.png",b="/k-blog/tcp/05/2023-02-19-15-11-13-image.png",m="/k-blog/tcp/05/2023-02-19-15-45-13-image.png",k="/k-blog/tcp/05/2023-02-19-15-54-45-image.png",_="/k-blog/tcp/05/2023-02-19-15-50-43-image.png",C="/k-blog/tcp/05/2023-02-19-16-02-30-image.png",f="/k-blog/tcp/05/2023-02-19-16-05-11-image.png",w="/k-blog/tcp/05/2023-02-19-16-11-17-image.png",v="/k-blog/tcp/05/2023-02-19-16-24-50-image.png",S="/k-blog/tcp/05/2023-02-19-16-26-26-image.png",x="/k-blog/tcp/05/2023-02-19-16-27-38-image.png",B="/k-blog/tcp/05/2023-02-19-16-31-57-image.png",R="/k-blog/tcp/05/2023-02-19-16-37-38-image.png",T="/k-blog/tcp/05/2023-02-19-16-36-34-image.png",A="/k-blog/tcp/05/2023-02-19-16-50-14-image.png",K="/k-blog/tcp/05/2023-02-19-16-51-05-image.png",I="/k-blog/tcp/05/2023-02-19-16-55-42-image.png",P="/k-blog/tcp/05/2023-02-19-16-57-14-image.png",M="/k-blog/tcp/05/2023-02-19-16-58-25-image.png",F="/k-blog/tcp/05/2023-02-19-16-58-49-image.png",L="/k-blog/tcp/05/2023-02-19-17-02-12-image.png",N="/k-blog/tcp/05/2023-02-19-17-03-59-image.png",G="/k-blog/tcp/05/2023-02-19-17-05-30-image.png",j=JSON.parse('{"title":"拥塞控制","description":"","frontmatter":{},"headers":[{"level":2,"title":"拥塞控制历史","slug":"拥塞控制历史","link":"#拥塞控制历史","children":[]},{"level":2,"title":"慢启动","slug":"慢启动","link":"#慢启动","children":[]},{"level":2,"title":"慢启动的初始窗口","slug":"慢启动的初始窗口","link":"#慢启动的初始窗口","children":[]},{"level":2,"title":"拥塞避免","slug":"拥塞避免","link":"#拥塞避免","children":[]},{"level":2,"title":"慢启动和拥塞避免","slug":"慢启动和拥塞避免","link":"#慢启动和拥塞避免","children":[]},{"level":2,"title":"快速重传","slug":"快速重传","link":"#快速重传","children":[{"level":3,"title":"为何会接收到失序数据段？","slug":"为何会接收到失序数据段","link":"#为何会接收到失序数据段","children":[]}]},{"level":2,"title":"快速重传（RFC2581）","slug":"快速重传-rfc2581","link":"#快速重传-rfc2581","children":[{"level":3,"title":"超时不会启动快速重传","slug":"超时不会启动快速重传","link":"#超时不会启动快速重传","children":[]},{"level":3,"title":"快速重传下一定要进入慢启动吗？","slug":"快速重传下一定要进入慢启动吗","link":"#快速重传下一定要进入慢启动吗","children":[]}]},{"level":2,"title":"快速恢复 (RFC2581)","slug":"快速恢复-rfc2581","link":"#快速恢复-rfc2581","children":[]},{"level":2,"title":"SACK与选择性重传算法","slug":"sack与选择性重传算法","link":"#sack与选择性重传算法","children":[{"level":3,"title":"进重传丢失端，保守乐观","slug":"进重传丢失端-保守乐观","link":"#进重传丢失端-保守乐观","children":[]},{"level":3,"title":"重传丢失段及后发送的所有段","slug":"重传丢失段及后发送的所有段","link":"#重传丢失段及后发送的所有段","children":[]},{"level":3,"title":"SACK: TCP Selective Acknowledgment","slug":"sack-tcp-selective-acknowledgment","link":"#sack-tcp-selective-acknowledgment","children":[]}]},{"level":2,"title":"从丢包到测量驱动的拥塞控制算法","slug":"从丢包到测量驱动的拥塞控制算法","link":"#从丢包到测量驱动的拥塞控制算法","children":[{"level":3,"title":"飞行中的数据和确认报文","slug":"飞行中的数据和确认报文","link":"#飞行中的数据和确认报文","children":[]},{"level":3,"title":"大管道向小管道传输数据引发拥堵","slug":"大管道向小管道传输数据引发拥堵","link":"#大管道向小管道传输数据引发拥堵","children":[]},{"level":3,"title":"最佳控制点在那？（1979 Leonard Kleinrock）","slug":"最佳控制点在那-1979-leonard-kleinrock","link":"#最佳控制点在那-1979-leonard-kleinrock","children":[]},{"level":3,"title":"空队列效果最好","slug":"空队列效果最好","link":"#空队列效果最好","children":[]},{"level":3,"title":"BBR: TCP Bottleneck Bandwidth and Round-trip propagation time","slug":"bbr-tcp-bottleneck-bandwidth-and-round-trip-propagation-time","link":"#bbr-tcp-bottleneck-bandwidth-and-round-trip-propagation-time","children":[]},{"level":3,"title":"Google BBR 拥塞控制算法原理","slug":"google-bbr-拥塞控制算法原理","link":"#google-bbr-拥塞控制算法原理","children":[]},{"level":3,"title":"BBR如何找到准确的RTprop和BtlBw?","slug":"bbr如何找到准确的rtprop和btlbw","link":"#bbr如何找到准确的rtprop和btlbw","children":[]},{"level":3,"title":"基于 pacing_gain 调整","slug":"基于-pacing-gain-调整","link":"#基于-pacing-gain-调整","children":[]},{"level":3,"title":"当线路变换式 pacing_gain 的作用","slug":"当线路变换式-pacing-gain-的作用","link":"#当线路变换式-pacing-gain-的作用","children":[]},{"level":3,"title":"对比 CUBIC 下的慢启动","slug":"对比-cubic-下的慢启动","link":"#对比-cubic-下的慢启动","children":[]},{"level":3,"title":"多条初始速度不同的 TCP 链路快速的平均分享带宽","slug":"多条初始速度不同的-tcp-链路快速的平均分享带宽","link":"#多条初始速度不同的-tcp-链路快速的平均分享带宽","children":[]},{"level":3,"title":"Google B4 WAN 实践","slug":"google-b4-wan-实践","link":"#google-b4-wan-实践","children":[]},{"level":3,"title":"RTT 大幅度下降","slug":"rtt-大幅度下降","link":"#rtt-大幅度下降","children":[]},{"level":3,"title":"不同丢包率下的吞吐量：CUBIC VS BBR","slug":"不同丢包率下的吞吐量-cubic-vs-bbr","link":"#不同丢包率下的吞吐量-cubic-vs-bbr","children":[]},{"level":3,"title":"SGSN 移动网络","slug":"sgsn-移动网络","link":"#sgsn-移动网络","children":[]},{"level":3,"title":"收到 ACK 时 更新 RTprop、BtlBw","slug":"收到-ack-时-更新-rtprop、btlbw","link":"#收到-ack-时-更新-rtprop、btlbw","children":[]},{"level":3,"title":"当发送数据时根据 pacing_gain 周期性探测带宽有没有发生变化","slug":"当发送数据时根据-pacing-gain-周期性探测带宽有没有发生变化","link":"#当发送数据时根据-pacing-gain-周期性探测带宽有没有发生变化","children":[]}]}],"relativePath":"tcp/05-拥塞控制.md"}'),U={name:"tcp/05-拥塞控制.md"},V=a('<h1 id="拥塞控制" tabindex="-1">拥塞控制 <a class="header-anchor" href="#拥塞控制" aria-hidden="true">#</a></h1><ul><li><p>慢启动</p></li><li><p>拥塞控制</p></li><li><p>快速重传</p></li><li><p>快速恢复</p></li></ul><img src="'+n+'"><p>由于 TCP 协议向应用层提供不定长的字节流发送方法，使的 TCP 有意愿去占满整个带宽，当网络中多个 TCP 连接同时试图建立整个带宽时，就可能发生恶心拥塞事件，TCP 拥塞控制算法就降低网络中的拥塞，提升所有 TCP 的连接速度</p><h2 id="拥塞控制历史" tabindex="-1">拥塞控制历史 <a class="header-anchor" href="#拥塞控制历史" aria-hidden="true">#</a></h2><ul><li><p>以丢包作为依据</p><ul><li><p>New Reno: RFC6582.BlC: Linux2.6.8-2.6.18</p></li><li><p>CUBIC (RFC8312) : Linux2.6.19</p></li></ul></li><li><p>以探测带宽作为依据</p><ul><li>BBR: Linux4.9</li></ul></li></ul><h2 id="慢启动" tabindex="-1">慢启动 <a class="header-anchor" href="#慢启动" aria-hidden="true">#</a></h2><ul><li><p>拥塞窗口cwnd(congestion window)</p><ul><li><p>通告窗口(接收窗口) rwnd (receiver`s advertised window)</p></li><li><p>发送窗口 swnd = min(cwnd, rwnd)</p></li></ul></li><li><p>每收到一个 ACK，cwnd 扩充为收到 ACK 的一倍</p></li></ul><img src="'+r+'"><h2 id="慢启动的初始窗口" tabindex="-1">慢启动的初始窗口 <a class="header-anchor" href="#慢启动的初始窗口" aria-hidden="true">#</a></h2><ul><li><p>慢启动初始窗口IW(Initial Window)的变迁</p><ul><li><p>1 SMSS: RFC2001 (1997)</p></li><li><p>2 - 4 SMSS: RFC2414 (1998)</p><ul><li>IW = min(4 * SMSS, max (2 * SMSS, 4380bytes))</li></ul></li><li><p>10 SMSS: RFC6928 (2013)</p><ul><li><p>IW = min(10 * MSS, max(2 * MSS, 14600))</p></li><li><p>gogle 发现大多数网页都在 10 个 MSS</p></li></ul></li></ul></li></ul><h2 id="拥塞避免" tabindex="-1">拥塞避免 <a class="header-anchor" href="#拥塞避免" aria-hidden="true">#</a></h2><img src="'+t+'"><p>在没有拥塞避免算法时，我们的慢启动时成线性增长，当出现丢包，丢包数量就可能非常大</p><p>比如上次 cwnd = 20，而我们超过 28 就开始丢包，下次收到 ack, cwnd = 40, 这样就会丢 12 个</p><ul><li><p><strong>拥塞避免定义了慢启动阈值 ssthresh(slow start threshold)</strong></p><ul><li><p>达到 ssthresh 后，以线性方式增加 cwnd</p></li><li><p>cwnd += SMSS * SMSS / cwnd</p></li></ul></li></ul><p>再出现<strong>丢包</strong>的情况就将 <strong>慢启动阈值降低为拥塞窗口的一半，再将拥塞定义为一个比较小的值</strong></p><h2 id="慢启动和拥塞避免" tabindex="-1">慢启动和拥塞避免 <a class="header-anchor" href="#慢启动和拥塞避免" aria-hidden="true">#</a></h2><img src="'+c+'"><h2 id="快速重传" tabindex="-1">快速重传 <a class="header-anchor" href="#快速重传" aria-hidden="true">#</a></h2><p>当出现丢包时我们会重新执行慢启动，传输效率也会大幅度下降，当出现场景不是很严重的时候，我们可以采用快速重传和快速恢复</p><h3 id="为何会接收到失序数据段" tabindex="-1">为何会接收到失序数据段？ <a class="header-anchor" href="#为何会接收到失序数据段" aria-hidden="true">#</a></h3><img src="'+p+'"><ul><li><p>若报文丢失，后续的报文到达我们接收端，将会发送连续的失序ACK段确认丢失的报文段</p><ul><li>拥塞控制针对丢包情况</li></ul></li><li><p>若网络路径与设备导致数据段失序，将会产生少量的失序ACK段</p></li><li><p>若报文重复，将会产生少量的失序ACK段</p></li></ul><h2 id="快速重传-rfc2581" tabindex="-1">快速重传（RFC2581） <a class="header-anchor" href="#快速重传-rfc2581" aria-hidden="true">#</a></h2><ul><li><p>接收方:</p><ul><li><p>当接收到一个失序数据段时，立刻发送它所期待的缺口ACK序列号</p></li><li><p>当接收到填充失序缺口的数据段时，立刻发送它所期待的下一个ACK序列号</p></li></ul></li><li><p>发送方</p><ul><li>当接收到 4 个相同的失序 ACK段时，不再等待重传定时器的触发，立刻基于快速重传机制重发报文段</li></ul></li></ul><img src="'+s+'"><h3 id="超时不会启动快速重传" tabindex="-1">超时不会启动快速重传 <a class="header-anchor" href="#超时不会启动快速重传" aria-hidden="true">#</a></h3><img src="'+d+'"><p>如上图 ack9 没有重复发送 达到 4 次，所以不启动</p><h3 id="快速重传下一定要进入慢启动吗" tabindex="-1">快速重传下一定要进入慢启动吗？ <a class="header-anchor" href="#快速重传下一定要进入慢启动吗" aria-hidden="true">#</a></h3><ul><li><p>收到重复的 ack，意味着网络仍在流动</p><ul><li>慢启动会突然减少数据流</li></ul></li></ul><h2 id="快速恢复-rfc2581" tabindex="-1">快速恢复 (RFC2581) <a class="header-anchor" href="#快速恢复-rfc2581" aria-hidden="true">#</a></h2><ul><li><p><strong>启动快速重传且正常未失序ACK段到达前(比如上图 pkt9)，启动快速恢复</strong></p><ul><li><p>将 ssthresh 设置为当前拥塞窗口 cwnd 的一半，设当前 cwnd 为 ssthresh 加上 3 * MSS</p></li><li><p>每收到一个重复 ACK , cwnd 增加 1 个 MSS</p></li><li><p>当新数据 ACK 到达后，设置 cwnd 为 ssthresh</p></li></ul></li></ul><img src="'+h+'"><h2 id="sack与选择性重传算法" tabindex="-1">SACK与选择性重传算法 <a class="header-anchor" href="#sack与选择性重传算法" aria-hidden="true">#</a></h2><h3 id="进重传丢失端-保守乐观" tabindex="-1">进重传丢失端，保守乐观 <a class="header-anchor" href="#进重传丢失端-保守乐观" aria-hidden="true">#</a></h3><ul><li><p>累积确认 Sequence 序号的问题</p><ul><li><p>Client 无法告知收到了 Part4</p></li><li><p>Server 发送窗口/Client 接收窗口停止</p></li></ul></li></ul><img src="'+o+'"><h3 id="重传丢失段及后发送的所有段" tabindex="-1">重传丢失段及后发送的所有段 <a class="header-anchor" href="#重传丢失段及后发送的所有段" aria-hidden="true">#</a></h3><ul><li><p>重传所有段: 积极悲观</p><ul><li>可能浪费带宽</li></ul></li><li><p>仅重传丢失段: 保守乐观</p><ul><li>大量丢包时效率低下</li></ul></li></ul><img src="'+g+'"><h3 id="sack-tcp-selective-acknowledgment" tabindex="-1">SACK: TCP Selective Acknowledgment <a class="header-anchor" href="#sack-tcp-selective-acknowledgment" aria-hidden="true">#</a></h3><ul><li>RFC 2018</li></ul><img src="'+u+'"><ul><li>选择性确认</li></ul><img src="'+b+'"><ul><li><p>Left Edge of Block</p></li><li><p>Right Edge of Block</p></li></ul><img src="'+m+'"><h2 id="从丢包到测量驱动的拥塞控制算法" tabindex="-1">从丢包到测量驱动的拥塞控制算法 <a class="header-anchor" href="#从丢包到测量驱动的拥塞控制算法" aria-hidden="true">#</a></h2><h3 id="飞行中的数据和确认报文" tabindex="-1">飞行中的数据和确认报文 <a class="header-anchor" href="#飞行中的数据和确认报文" aria-hidden="true">#</a></h3><img src="'+k+'"><p>瓶颈路由器，在瓶颈路由器过载，等待队列全满 就会出现丢包</p><h3 id="大管道向小管道传输数据引发拥堵" tabindex="-1">大管道向小管道传输数据引发拥堵 <a class="header-anchor" href="#大管道向小管道传输数据引发拥堵" aria-hidden="true">#</a></h3><img src="'+_+'"><p>在瓶颈路由器开始丢包</p><img src="'+C+'"><p>y: 发送速率</p><p>x: 时间</p><img src="'+f+'"><p>在引入 CUBIC 拥塞控制算法后，他虽然更加平滑，但他也会带来我们 RTT 时延非常大</p><h3 id="最佳控制点在那-1979-leonard-kleinrock" tabindex="-1">最佳控制点在那？（1979 Leonard Kleinrock） <a class="header-anchor" href="#最佳控制点在那-1979-leonard-kleinrock" aria-hidden="true">#</a></h3><ul><li><p>基于丢包的拥塞控制点</p><ul><li><p>高时延，大量丢包</p></li><li><p>随着内存便宜，缓冲队列越大，时延更高</p></li></ul></li><li><p>最佳控制点</p><ul><li><p>最大带宽下</p></li><li><p>最小时延</p></li><li><p>最低丢包率</p></li></ul></li><li><p>RTT 与 Bw 独立变化</p><ul><li>同时只有一个可以被准确测量</li></ul></li></ul><img src="'+w+'"><p>Round Trip TIme： RTT</p><p>Data Volume In-Flight: 缓冲队列</p><p>Delivery Rate: 带宽</p><h3 id="空队列效果最好" tabindex="-1">空队列效果最好 <a class="header-anchor" href="#空队列效果最好" aria-hidden="true">#</a></h3><img src="'+v+'"><p>当我们缓冲队列满了就开始丢包，我们最佳的点就是缓冲队列开始丢包</p><img src="'+S+'"><h3 id="bbr-tcp-bottleneck-bandwidth-and-round-trip-propagation-time" tabindex="-1">BBR: TCP Bottleneck Bandwidth and Round-trip propagation time <a class="header-anchor" href="#bbr-tcp-bottleneck-bandwidth-and-round-trip-propagation-time" aria-hidden="true">#</a></h3><ul><li>由Google于2016发布，Linux4.9内核引入，QUIC使用</li></ul><img src="'+x+'"><h3 id="google-bbr-拥塞控制算法原理" tabindex="-1">Google BBR 拥塞控制算法原理 <a class="header-anchor" href="#google-bbr-拥塞控制算法原理" aria-hidden="true">#</a></h3><h4 id="最佳控制点在那" tabindex="-1">最佳控制点在那? <a class="header-anchor" href="#最佳控制点在那" aria-hidden="true">#</a></h4><ul><li>1979 Leonard Kleinrock</li></ul><img src="'+B+'"><h3 id="bbr如何找到准确的rtprop和btlbw" tabindex="-1">BBR如何找到准确的RTprop和BtlBw? <a class="header-anchor" href="#bbr如何找到准确的rtprop和btlbw" aria-hidden="true">#</a></h3><img src="'+R+'"><p>nt 是排队时间</p><p>RTprop 是从发送到接收数据整个的时间(不包括排队的时间)</p><h3 id="基于-pacing-gain-调整" tabindex="-1">基于 pacing_gain 调整 <a class="header-anchor" href="#基于-pacing-gain-调整" aria-hidden="true">#</a></h3><ul><li><p>700 ms 内的测量</p><ul><li>10-Mbps, 40 ms 链路</li></ul></li><li><p>如果检测带宽变大？</p><ul><li>定期提升 pacing_gain</li></ul></li></ul><img src="'+T+'"><h3 id="当线路变换式-pacing-gain-的作用" tabindex="-1">当线路变换式 pacing_gain 的作用 <a class="header-anchor" href="#当线路变换式-pacing-gain-的作用" aria-hidden="true">#</a></h3><img src="'+A+'"><h3 id="对比-cubic-下的慢启动" tabindex="-1">对比 CUBIC 下的慢启动 <a class="header-anchor" href="#对比-cubic-下的慢启动" aria-hidden="true">#</a></h3><img src="'+K+'"><h3 id="多条初始速度不同的-tcp-链路快速的平均分享带宽" tabindex="-1">多条初始速度不同的 TCP 链路快速的平均分享带宽 <a class="header-anchor" href="#多条初始速度不同的-tcp-链路快速的平均分享带宽" aria-hidden="true">#</a></h3><ul><li>100-Mbps/10-ms</li></ul><img src="'+I+'"><h3 id="google-b4-wan-实践" tabindex="-1">Google B4 WAN 实践 <a class="header-anchor" href="#google-b4-wan-实践" aria-hidden="true">#</a></h3><ul><li><p>2-25倍吞吐量提升</p></li><li><p>累积分布函数</p></li><li><p>75%连接受限于linux kerver 接收缓存</p></li><li><p>在美国-欧洲路径上提升linuxkernal接收缓存上限后有133倍提升</p></li></ul><img src="'+P+'"><h3 id="rtt-大幅度下降" tabindex="-1">RTT 大幅度下降 <a class="header-anchor" href="#rtt-大幅度下降" aria-hidden="true">#</a></h3><img src="'+M+'"><h3 id="不同丢包率下的吞吐量-cubic-vs-bbr" tabindex="-1">不同丢包率下的吞吐量：CUBIC VS BBR <a class="header-anchor" href="#不同丢包率下的吞吐量-cubic-vs-bbr" aria-hidden="true">#</a></h3><img src="'+F+'"><h3 id="sgsn-移动网络" tabindex="-1">SGSN 移动网络 <a class="header-anchor" href="#sgsn-移动网络" aria-hidden="true">#</a></h3><img src="'+L+'"><p>三次握手建立连接的重发次数和超时实践都是有限的</p><h3 id="收到-ack-时-更新-rtprop、btlbw" tabindex="-1">收到 ACK 时 更新 RTprop、BtlBw <a class="header-anchor" href="#收到-ack-时-更新-rtprop、btlbw" aria-hidden="true">#</a></h3><img src="'+N+'"><h3 id="当发送数据时根据-pacing-gain-周期性探测带宽有没有发生变化" tabindex="-1">当发送数据时根据 pacing_gain 周期性探测带宽有没有发生变化 <a class="header-anchor" href="#当发送数据时根据-pacing-gain-周期性探测带宽有没有发生变化" aria-hidden="true">#</a></h3><img src="'+G+'">',106),W=[V];function D(E,$,y,q,J,O){return e(),l("div",null,W)}const z=i(U,[["render",D]]);export{j as __pageData,z as default};
