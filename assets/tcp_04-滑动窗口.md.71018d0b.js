import{_ as l,c as e,o as i,a}from"./app.80fd2797.js";const n="/k-blog/tcp/04/2023-02-12-11-05-06-image.png",s="/k-blog/tcp/04/2023-02-12-11-45-16-image.png",t="/k-blog/tcp/04/2023-02-12-11-47-07-image.png",r="/k-blog/tcp/04/2023-02-12-11-48-58-image.png",c="/k-blog/tcp/04/2023-02-12-11-52-35-image.png",p="/k-blog/tcp/04/2023-02-12-11-56-28-image.png",d="/k-blog/tcp/04/2023-02-12-12-42-01-image.png",o="/k-blog/tcp/04/2023-02-12-12-59-19-image.png",h="/k-blog/tcp/04/2023-02-12-13-00-07-image.png",g="/k-blog/tcp/04/2023-02-12-13-07-43-image.png",u="/k-blog/tcp/04/2023-02-12-13-11-49-image.png",m="/k-blog/tcp/04/2023-02-12-13-24-18-image.png",_="/k-blog/tcp/04/2023-02-12-19-47-18-image.png",k="/k-blog/tcp/04/2023-02-12-19-56-41-image.png",b="/k-blog/tcp/04/2023-02-12-20-05-34-image.png",x="/k-blog/tcp/04/2023-02-12-20-08-39-image.png",v="/k-blog/tcp/04/2023-02-12-20-05-54-image.png",y="/k-blog/tcp/04/2023-02-12-20-24-10-image.png",L=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"发送窗口和接收窗口","slug":"发送窗口和接收窗口","link":"#发送窗口和接收窗口","children":[{"level":3,"title":"发送窗口快照","slug":"发送窗口快照","link":"#发送窗口快照","children":[]},{"level":3,"title":"可用窗口/发送窗口","slug":"可用窗口-发送窗口","link":"#可用窗口-发送窗口","children":[]},{"level":3,"title":"可用窗口耗尽","slug":"可用窗口耗尽","link":"#可用窗口耗尽","children":[]},{"level":3,"title":"发送窗口移动","slug":"发送窗口移动","link":"#发送窗口移动","children":[]},{"level":3,"title":"发送窗口","slug":"发送窗口","link":"#发送窗口","children":[]},{"level":3,"title":"约等于对端发送窗口的接收窗口","slug":"约等于对端发送窗口的接收窗口","link":"#约等于对端发送窗口的接收窗口","children":[]}]},{"level":2,"title":"窗口的滑动与流量控制","slug":"窗口的滑动与流量控制","link":"#窗口的滑动与流量控制","children":[{"level":3,"title":"窗口滑动示例：MSS 不产生影响，窗口不变","slug":"窗口滑动示例-mss-不产生影响-窗口不变","link":"#窗口滑动示例-mss-不产生影响-窗口不变","children":[]}]},{"level":2,"title":"客户端发送消息","slug":"客户端发送消息","link":"#客户端发送消息","children":[]},{"level":2,"title":"服务器端发送消息","slug":"服务器端发送消息","link":"#服务器端发送消息","children":[]},{"level":2,"title":"操作系统缓冲区与滑动窗口的关系","slug":"操作系统缓冲区与滑动窗口的关系","link":"#操作系统缓冲区与滑动窗口的关系","children":[{"level":3,"title":"窗口与缓存","slug":"窗口与缓存","link":"#窗口与缓存","children":[]},{"level":3,"title":"收缩窗口导致的丢包","slug":"收缩窗口导致的丢包","link":"#收缩窗口导致的丢包","children":[]},{"level":3,"title":"飞行中报文的合适数量","slug":"飞行中报文的合适数量","link":"#飞行中报文的合适数量","children":[]},{"level":3,"title":"Linux下调整接收窗口与应用缓存","slug":"linux下调整接收窗口与应用缓存","link":"#linux下调整接收窗口与应用缓存","children":[]},{"level":3,"title":"Linux中对TCP缓冲区的调整方式","slug":"linux中对tcp缓冲区的调整方式","link":"#linux中对tcp缓冲区的调整方式","children":[]}]},{"level":2,"title":"如何减少小报文提高网络效率","slug":"如何减少小报文提高网络效率","link":"#如何减少小报文提高网络效率","children":[{"level":3,"title":"SWS (Silly Window syndrome) 糊涂窗口综合征","slug":"sws-silly-window-syndrome-糊涂窗口综合征","link":"#sws-silly-window-syndrome-糊涂窗口综合征","children":[]},{"level":3,"title":"SWS 避免算法","slug":"sws-避免算法","link":"#sws-避免算法","children":[]},{"level":3,"title":"TCP delayed acknowledgment 延迟确认","slug":"tcp-delayed-acknowledgment-延迟确认","link":"#tcp-delayed-acknowledgment-延迟确认","children":[]},{"level":3,"title":"Nagle VS delayed ACK","slug":"nagle-vs-delayed-ack","link":"#nagle-vs-delayed-ack","children":[]},{"level":3,"title":"Linux -上更为激进的\\"Nagle\\": TCP_ CORK","slug":"linux-上更为激进的-nagle-tcp-cork","link":"#linux-上更为激进的-nagle-tcp-cork","children":[]}]}],"relativePath":"tcp/04-滑动窗口.md"}'),C={name:"tcp/04-滑动窗口.md"},f=a('<h2 id="发送窗口和接收窗口" tabindex="-1">发送窗口和接收窗口 <a class="header-anchor" href="#发送窗口和接收窗口" aria-hidden="true">#</a></h2><h3 id="发送窗口快照" tabindex="-1">发送窗口快照 <a class="header-anchor" href="#发送窗口快照" aria-hidden="true">#</a></h3><ol><li><p>已发送并收到Ack确认的数据: 1-31字节</p></li><li><p>已发送未收到 Ack确认的数据: 32-45字节</p></li><li><p>未发送但总大小在接收方处理范围内: 46-51字节</p></li><li><p>未发送但总大小超出接收方处理范围: 52-字节</p></li></ol><img src="'+n+'"><h3 id="可用窗口-发送窗口" tabindex="-1">可用窗口/发送窗口 <a class="header-anchor" href="#可用窗口-发送窗口" aria-hidden="true">#</a></h3><ul><li><p>可用窗口：46-51字节</p></li><li><p>发送窗口：32-51 字节</p></li></ul><img src="'+s+'"><h3 id="可用窗口耗尽" tabindex="-1">可用窗口耗尽 <a class="header-anchor" href="#可用窗口耗尽" aria-hidden="true">#</a></h3><ul><li>46-51 字节已发送，</li><li></li></ul><img src="'+t+'"><h3 id="发送窗口移动" tabindex="-1">发送窗口移动 <a class="header-anchor" href="#发送窗口移动" aria-hidden="true">#</a></h3><ul><li>32 到 36字节已确认</li></ul><img src="'+r+'"><h3 id="发送窗口" tabindex="-1">发送窗口 <a class="header-anchor" href="#发送窗口" aria-hidden="true">#</a></h3><ul><li><p>SND.WND(发送窗口)</p></li><li><p>SND.UNA(指向已发送未接收的头位置)</p></li><li><p>SND.NXT(指向已发送未接收部分结束的下一个字节)</p></li></ul><img src="'+c+'"><h3 id="约等于对端发送窗口的接收窗口" tabindex="-1">约等于对端发送窗口的接收窗口 <a class="header-anchor" href="#约等于对端发送窗口的接收窗口" aria-hidden="true">#</a></h3><ul><li><p>RCV.WND</p></li><li><p>RCV.NXT</p></li></ul><img src="'+p+'"><h2 id="窗口的滑动与流量控制" tabindex="-1">窗口的滑动与流量控制 <a class="header-anchor" href="#窗口的滑动与流量控制" aria-hidden="true">#</a></h2><h3 id="窗口滑动示例-mss-不产生影响-窗口不变" tabindex="-1">窗口滑动示例：MSS 不产生影响，窗口不变 <a class="header-anchor" href="#窗口滑动示例-mss-不产生影响-窗口不变" aria-hidden="true">#</a></h3><img src="'+d+'"><h2 id="客户端发送消息" tabindex="-1">客户端发送消息 <a class="header-anchor" href="#客户端发送消息" aria-hidden="true">#</a></h2><img src="'+o+'"><h2 id="服务器端发送消息" tabindex="-1">服务器端发送消息 <a class="header-anchor" href="#服务器端发送消息" aria-hidden="true">#</a></h2><img src="'+h+'"><h2 id="操作系统缓冲区与滑动窗口的关系" tabindex="-1">操作系统缓冲区与滑动窗口的关系 <a class="header-anchor" href="#操作系统缓冲区与滑动窗口的关系" aria-hidden="true">#</a></h2><p>在实际中发送窗口和接收窗口所存放的字节都是放在操作系统的缓冲区中，操作系统的缓冲区会被操作系统调整，当我们的应用进程没有办法及时读取缓冲区的内容是，也会对我们缓冲区有影响</p><h3 id="窗口与缓存" tabindex="-1">窗口与缓存 <a class="header-anchor" href="#窗口与缓存" aria-hidden="true">#</a></h3><img src="'+g+'"><ul><li>在上面这幅图中可以看出，应用层没有及时读取缓存，导致窗口一直收缩，直到窗口关闭</li></ul><h3 id="收缩窗口导致的丢包" tabindex="-1">收缩窗口导致的丢包 <a class="header-anchor" href="#收缩窗口导致的丢包" aria-hidden="true">#</a></h3><img src="'+u+'"><p>Sever 和 Clinet 窗口大小都为 360，而 Sever 在收到第一个请求后出现了缓存收缩的行为，导致接收窗口变小而且应用进程也没有及时读取，Client 在没有收到 Sever 发送的窗口大小，就发送了新的请求而且超出了缓存区大小，只能丢掉</p><p>实际操作系统为了避免这个问题</p><ul><li><p>会先收缩窗口，在减少缓存</p></li><li><p>窗口关闭后，定时探测窗口大小</p></li></ul><h3 id="飞行中报文的合适数量" tabindex="-1">飞行中报文的合适数量 <a class="header-anchor" href="#飞行中报文的合适数量" aria-hidden="true">#</a></h3><ul><li>bps * RTT</li></ul><img src="'+m+'"><h3 id="linux下调整接收窗口与应用缓存" tabindex="-1">Linux下调整接收窗口与应用缓存 <a class="header-anchor" href="#linux下调整接收窗口与应用缓存" aria-hidden="true">#</a></h3><p>net.ipv4.tcp_ <em>adv</em> <em>win</em> scale= 1</p><p>应用缓存= buffer / (2^tcp_ <em>adv</em> <em>win</em> scale)</p><h3 id="linux中对tcp缓冲区的调整方式" tabindex="-1">Linux中对TCP缓冲区的调整方式 <a class="header-anchor" href="#linux中对tcp缓冲区的调整方式" aria-hidden="true">#</a></h3><ul><li><p>net.ipv4.tcp_ rmem = 4096 87380 6291456</p><ul><li>读缓存最小值、默认值、最大值，单位字节，覆盖net.core.rmem max</li></ul></li><li><p>net.ipv4.tcp_ wmem = 4096 16384 41 94304</p><ul><li>写缓存最小值、默认值、最大值，单位字节，覆盖net.core.wmem_ max</li></ul></li><li><p>net.ipv4.tcp_ mem = 1541646 2055528 3083292</p><ul><li>系统无内存压力、启动压力模式阀值、最大值，单位为页的数量s</li></ul></li><li><p>nct.ipv4.tcp_ moderate_ rcvbuf = 1</p><ul><li>开启自动调整缓存模式</li></ul></li></ul><h2 id="如何减少小报文提高网络效率" tabindex="-1">如何减少小报文提高网络效率 <a class="header-anchor" href="#如何减少小报文提高网络效率" aria-hidden="true">#</a></h2><h3 id="sws-silly-window-syndrome-糊涂窗口综合征" tabindex="-1">SWS (Silly Window syndrome) 糊涂窗口综合征 <a class="header-anchor" href="#sws-silly-window-syndrome-糊涂窗口综合征" aria-hidden="true">#</a></h3><ul><li>服务器应用读取缓存较慢，导致窗口逐渐变小，客户端一直发送小报文</li></ul><img src="'+_+'"><h3 id="sws-避免算法" tabindex="-1">SWS 避免算法 <a class="header-anchor" href="#sws-避免算法" aria-hidden="true">#</a></h3><ul><li><p>接收方</p><ul><li>David D Clark 算法：窗口边界移动值小于 min (MSS, 缓存/2) 是，通知窗口为 0</li></ul></li><li><p>发送方</p><ul><li><p>Nagle 算法： TCP_NODELAY 用于关闭 Nagle 算法</p><ul><li><p>没有已发送未确认报文段时，立即发送数据</p></li><li><p>存在未确认报文段时</p><ul><li><p>直到没有已发送未确认报文段</p></li><li><p>或者数据长度达到 MSS 时再发送</p></li></ul></li></ul></li></ul></li></ul><img src="'+k+'"><h3 id="tcp-delayed-acknowledgment-延迟确认" tabindex="-1">TCP delayed acknowledgment 延迟确认 <a class="header-anchor" href="#tcp-delayed-acknowledgment-延迟确认" aria-hidden="true">#</a></h3><ul><li><p>当有响应数据要发送时，ack 会随着响应数据立即发送给对方</p></li><li><p>如果没有响应数据，ack 的发送将会有一个延迟，以等待看是否有响应数据可以一起发送</p></li><li><p>如果在等待发送 ack 期间，对方的第二个数据段又到达了，这时要立即发送 ack</p></li></ul><img src="'+b+'"><img src="'+x+'"><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">cat </span><span style="color:#89DDFF;">/</span><span style="color:#A6ACCD;">boot</span><span style="color:#89DDFF;">/</span><span style="color:#A6ACCD;">config</span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">`</span><span style="color:#C3E88D;">uname -r</span><span style="color:#89DDFF;">`</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">|</span><span style="color:#A6ACCD;"> grep </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">I^CONFIG HZ=</span><span style="color:#89DDFF;">&#39;</span></span>\n<span class="line"></span></code></pre></div><img src="'+v+'"><p>但是，我们的 <strong>Nagle 算法</strong> 和 <strong>延迟确认</strong> 在一起会存在一个问题</p><p><strong>Nagle 算法</strong> 要等 <strong>数据确认后</strong> 再发送下一个报文，而 <strong>延迟确认</strong> 在没接收到下一个数据就会进入长时间的等待</p><h3 id="nagle-vs-delayed-ack" tabindex="-1">Nagle VS delayed ACK <a class="header-anchor" href="#nagle-vs-delayed-ack" aria-hidden="true">#</a></h3><p>Nagle 算法下一定会有一个小报文，其他报文，为了避免小报文的长时间等待，只能关闭一方</p><ul><li><p>关闭 delayed ACK: TCP_ QUICKACK</p></li><li><p>关闭 Nagle: TCP_ NODELAY</p></li></ul><img src="'+y+'"><h3 id="linux-上更为激进的-nagle-tcp-cork" tabindex="-1">Linux -上更为激进的&quot;Nagle&quot;: TCP_ CORK <a class="header-anchor" href="#linux-上更为激进的-nagle-tcp-cork" aria-hidden="true">#</a></h3><ul><li><p>Nagle 算法 还允许网络有一个已发送发未确认的小报文，而 TCP_ CORK 则允许所有必须是大的报文</p></li><li><p>但是必须结合sendfile零拷贝技术使用</p></li></ul>',65),D=[f];function S(w,N,A,T,F,P){return i(),e("div",null,D)}const W=l(C,[["render",S]]);export{L as __pageData,W as default};
