import{_ as l,c as i,o as e,a as p}from"./app.80fd2797.js";const a="/k-blog/tcp/01/2023-02-11-08-57-19-image.png",t="/k-blog/tcp/01/2023-02-11-08-59-30-image.png",n="/k-blog/tcp/01/2023-02-11-09-08-28-image.png",s="/k-blog/tcp/01/2023-02-11-09-14-59-image.png",c="/k-blog/tcp/01/2023-02-11-09-30-12-image.png",r="/k-blog/tcp/01/2023-02-11-10-36-03-image.png",d="/k-blog/tcp/01/2023-02-11-10-43-09-image.png",h="/k-blog/tcp/01/2023-02-11-10-45-46-image.png",o="/k-blog/tcp/01/2023-02-11-11-04-29-image.png",u="/k-blog/tcp/01/2023-02-11-11-21-39-image.png",P="/k-blog/tcp/01/2023-02-11-11-28-56-image.png",g="/k-blog/tcp/01/2023-02-11-11-37-36-image.png",C="/k-blog/tcp/01/2023-02-11-11-43-05-image.png",T="/k-blog/tcp/01/2023-02-11-11-48-05-image.png",F=JSON.parse('{"title":"TCP 简介","description":"","frontmatter":{"title":"TCP 简介","isTop":true,"date":"2023/02/10","tags":["TCP"]},"headers":[{"level":2,"title":"TCP 历史及其设计哲学","slug":"tcp-历史及其设计哲学","link":"#tcp-历史及其设计哲学","children":[{"level":3,"title":"1973 TCP/IP 协议","slug":"_1973-tcp-ip-协议","link":"#_1973-tcp-ip-协议","children":[]},{"level":3,"title":"TCP/IP 协议发展","slug":"tcp-ip-协议发展","link":"#tcp-ip-协议发展","children":[]},{"level":3,"title":"TCPv4 协议分层后的互联网世界","slug":"tcpv4-协议分层后的互联网世界","link":"#tcpv4-协议分层后的互联网世界","children":[]},{"level":3,"title":"TCP/IP 的七个设计理念","slug":"tcp-ip-的七个设计理念","link":"#tcp-ip-的七个设计理念","children":[]}]},{"level":2,"title":"TCP 解决了那些问题","slug":"tcp-解决了那些问题","link":"#tcp-解决了那些问题","children":[{"level":3,"title":"TCP 的作用","slug":"tcp-的作用","link":"#tcp-的作用","children":[]},{"level":3,"title":"TCP 协议的分层","slug":"tcp-协议的分层","link":"#tcp-协议的分层","children":[]},{"level":3,"title":"层层签到的”信封“：报文头部","slug":"层层签到的-信封-报文头部","link":"#层层签到的-信封-报文头部","children":[]},{"level":3,"title":"报文头部的层层组装与卸载","slug":"报文头部的层层组装与卸载","link":"#报文头部的层层组装与卸载","children":[]},{"level":3,"title":"TCP 协议特点","slug":"tcp-协议特点","link":"#tcp-协议特点","children":[]}]},{"level":2,"title":"TCP 报文格式","slug":"tcp-报文格式","link":"#tcp-报文格式","children":[{"level":3,"title":"消息传输的核心要素","slug":"消息传输的核心要素","link":"#消息传输的核心要素","children":[]},{"level":3,"title":"IP 头部","slug":"ip-头部","link":"#ip-头部","children":[]},{"level":3,"title":"UDP 头部","slug":"udp-头部","link":"#udp-头部","children":[]},{"level":3,"title":"TCP 协议的任务","slug":"tcp-协议的任务","link":"#tcp-协议的任务","children":[]},{"level":3,"title":"如何标识一个连接","slug":"如何标识一个连接","link":"#如何标识一个连接","children":[]},{"level":3,"title":"TCP Segment 报文段","slug":"tcp-segment-报文段","link":"#tcp-segment-报文段","children":[]},{"level":3,"title":"常用选项","slug":"常用选项","link":"#常用选项","children":[]}]},{"level":2,"title":"如何使用 tcpdump","slug":"如何使用-tcpdump","link":"#如何使用-tcpdump","children":[{"level":3,"title":"捕获及停止条件","slug":"捕获及停止条件","link":"#捕获及停止条件","children":[]}]}],"relativePath":"tcp/01-TCP简介.md"}'),m={name:"tcp/01-TCP简介.md"},_=p('<h1 id="tcp-简介" tabindex="-1">TCP 简介 <a class="header-anchor" href="#tcp-简介" aria-hidden="true">#</a></h1><h2 id="tcp-历史及其设计哲学" tabindex="-1">TCP 历史及其设计哲学 <a class="header-anchor" href="#tcp-历史及其设计哲学" aria-hidden="true">#</a></h2><p>TCP/IP 的前身是美国国防部的 APRA 网中的 NCP 协议</p><p>NCP 协议没有遵循 OSI 七层模型，网络层和传输层都融在 NCP 这一个协议</p><ul><li>存在问题 <ul><li>一是这个网络中只有一台主机对另一台主机通讯，没有 IP地址这个概念</li><li>二是这个网络中没有容错功能，这个网络扩大的时候错误明显提高，网络效率低下</li></ul></li></ul><h3 id="_1973-tcp-ip-协议" tabindex="-1">1973 TCP/IP 协议 <a class="header-anchor" href="#_1973-tcp-ip-协议" aria-hidden="true">#</a></h3><img src="'+a+'"><h3 id="tcp-ip-协议发展" tabindex="-1">TCP/IP 协议发展 <a class="header-anchor" href="#tcp-ip-协议发展" aria-hidden="true">#</a></h3><img src="'+t+'"><ul><li><p>1973 年提出 TCP v1, 这是还没有 IP 协议，IP 协议的功能都包含在 TCP 中</p></li><li><p>1978 年 <strong>Jon Postel</strong> 提出了 TCP 协议，没有按照 OSI 进行分层</p></li><li><p>1980 年 TCP 就被分层，分为 TCP v4 和 IPV4，这也就是为什么没有 IP v1 2 3 的原因</p></li></ul><h3 id="tcpv4-协议分层后的互联网世界" tabindex="-1">TCPv4 协议分层后的互联网世界 <a class="header-anchor" href="#tcpv4-协议分层后的互联网世界" aria-hidden="true">#</a></h3><img src="'+n+'"><ul><li><p>IP 协议，专注解决如 何在网络中传递消息</p></li><li><p>TCP 协议 解决了任意长度消息的传输，而且可以保证是可靠的传输，让应用层可以不用考虑这些问题</p></li></ul><h3 id="tcp-ip-的七个设计理念" tabindex="-1">TCP/IP 的七个设计理念 <a class="header-anchor" href="#tcp-ip-的七个设计理念" aria-hidden="true">#</a></h3><img src="'+s+'"><ol><li><p>APRA 网最大的问题容错率很低，所以 TCP/IP 的设计理念要能够容错，所以我们 TCP x协议中会有基于滑动窗口的容错机制</p></li><li><p>APRA 网是军工网络，军工网络相对是不开王，要求 TCP/IP 协议必须支持不同类型的网络设备，斯克，华为各种不同的路由器和交换机</p></li><li><p>当初想把 APRA 网与其网络进行连接遇到了问题，所以 TCP/IP 的设计理念能够连接各种不同种类的网络，WIFI，海底光纤，光缆</p></li></ol><h2 id="tcp-解决了那些问题" tabindex="-1">TCP 解决了那些问题 <a class="header-anchor" href="#tcp-解决了那些问题" aria-hidden="true">#</a></h2><h3 id="tcp-的作用" tabindex="-1">TCP 的作用 <a class="header-anchor" href="#tcp-的作用" aria-hidden="true">#</a></h3><img src="'+c+'"><p>这幅图中存在三个网络，客户端网络，广域网，服务端网络</p><p>客户端网络发起了网络请求先由这条蓝色的线，先由数据链路层发送到路由器上，根据我们网络层也就是 IP 层选择最短的路径，TCP 则是把我们这个不定长度 HTTP 请求，切分成 TCP 认为合适的段，在中间任意一个结点中这个报文可能会被丢掉，路径也有可能发生变化，TCP 必须保证每一个段必须到达 HTTP Server，TCP 都是由操作系统的内核实现的，将 HTTP Request 相同的顺序交给 Tomact 登服务器，Tomact 处理完生成 web 页面, 通过相同的路径返回</p><p>在这样的网络中如何选入跨越不同的网络是由我们的 IP 和数据链路层决定的，如何构造消息和响应是由应用层决定的，数据如何可靠的发出，如何保证顺序是由 TCP 协议决定的</p><h3 id="tcp-协议的分层" tabindex="-1">TCP 协议的分层 <a class="header-anchor" href="#tcp-协议的分层" aria-hidden="true">#</a></h3><ul><li><p>TCP: 面向连接的、可靠的、基于字节流的传输层通信协议</p><ul><li><p>面向连接：一对一的</p></li><li><p>可靠的：网络链路中出现了怎样的链路变化，TCP 协议都可以保证一个报文一定能够最终到达接收端</p></li><li><p>基于字节流：消息是没有边界的，保证有序的，即使先接受到后面的字节，也不能扔给应用层去处理</p></li></ul></li><li><p>IP: 根据 IP 地址穿越网络传输数据</p></li></ul><img src="'+r+'"><h3 id="层层签到的-信封-报文头部" tabindex="-1">层层签到的”信封“：报文头部 <a class="header-anchor" href="#层层签到的-信封-报文头部" aria-hidden="true">#</a></h3><img src="'+d+'"><h3 id="报文头部的层层组装与卸载" tabindex="-1">报文头部的层层组装与卸载 <a class="header-anchor" href="#报文头部的层层组装与卸载" aria-hidden="true">#</a></h3><ul><li><p>不可靠的网络传输</p><ul><li><p>网络设备</p></li><li><p>主机</p></li><li><p>物理链路</p></li></ul></li></ul><img src="'+h+'"><h3 id="tcp-协议特点" tabindex="-1">TCP 协议特点 <a class="header-anchor" href="#tcp-协议特点" aria-hidden="true">#</a></h3><ul><li><p><strong>在IP协议之上，解决网络通讯可依赖问题</strong></p><ul><li><p>点对点(不能广播、多播)，面向连接</p></li><li><p>双向传递(全双工)</p></li><li><p>字节流：打包成报文段、保证有序接收、重复报文自动丢弃</p><ul><li><p>缺点：不维护应用报文的边界(对比HTTP HTTP报文必须自己去做 /r/n 结尾、 GRPC)</p></li><li><p>优点：不强制要求应用必须离散的创建数据块，不限制数据块大</p></li></ul></li><li><p>流量缓冲：解决速度不匹配问题</p><ul><li>客户端和服务器设备可能不一样，处理速度不匹配</li></ul></li><li><p>可靠的传输服务(保证可达，丢包时通过重发进而增加时延实现可靠性)</p></li><li><p>拥塞控制</p></li></ul></li></ul><h2 id="tcp-报文格式" tabindex="-1">TCP 报文格式 <a class="header-anchor" href="#tcp-报文格式" aria-hidden="true">#</a></h2><h3 id="消息传输的核心要素" tabindex="-1">消息传输的核心要素 <a class="header-anchor" href="#消息传输的核心要素" aria-hidden="true">#</a></h3><img src="'+o+'"><ul><li><p>寄件人与收件人信息</p><ul><li><p>IP 地址</p></li><li><p>TCP(UDP) 端口</p></li><li><p>HTTP Host/URI 等</p></li></ul></li><li><p>物流订单号</p><ul><li><p>IP 序列号</p></li><li><p>TCP 序列号</p></li></ul></li><li><p>物流系统需求</p></li></ul><h3 id="ip-头部" tabindex="-1">IP 头部 <a class="header-anchor" href="#ip-头部" aria-hidden="true">#</a></h3><img src="'+u+'"><ul><li><p>Source Address：源地址</p></li><li><p>Destination Address：目标地址</p></li><li><p>Identification：IP序列号(物流订单号)</p></li><li><p>TTL: IP 数据包在计算机网络中可以转发的最大跳数</p><ul><li>TTL减少为0，路由器将会丢弃收到的TTL=0的IP包并向IP包的发送者发送 ICMP time exceeded消息。</li></ul></li></ul><h3 id="udp-头部" tabindex="-1">UDP 头部 <a class="header-anchor" href="#udp-头部" aria-hidden="true">#</a></h3><img src="'+P+'"><ul><li><p>Source Port：源端口</p></li><li><p>Destination Port：目标端口</p></li><li><p>Checksum：容错的效验码</p></li></ul><h3 id="tcp-协议的任务" tabindex="-1">TCP 协议的任务 <a class="header-anchor" href="#tcp-协议的任务" aria-hidden="true">#</a></h3><ul><li><p>主机内的进程寻址</p></li><li><p>创建、管理、终止连接</p></li><li><p>处理并将 <strong>字节(8bit)</strong> 流打包成报文段(如IP报文)</p></li><li><p>传输数据</p></li><li><p>保持可靠性与传输质量</p></li><li><p>流控制与拥塞控制</p></li></ul><h3 id="如何标识一个连接" tabindex="-1">如何标识一个连接 <a class="header-anchor" href="#如何标识一个连接" aria-hidden="true">#</a></h3><ul><li><p><strong>TCP 四元组(源地址，源端口，目的地址，目的端口)</strong></p><ul><li>对于 IPv4 地址，单主机最大 TCP 连接数为 2^(32 + 16 + 32 + 16)</li></ul></li><li><p>没有连接 ID：QUIC 协议</p></li></ul><img src="'+g+'"><h3 id="tcp-segment-报文段" tabindex="-1">TCP Segment 报文段 <a class="header-anchor" href="#tcp-segment-报文段" aria-hidden="true">#</a></h3><ul><li><p>控制信息</p><ul><li><p>寻址</p></li><li><p>滑动窗口</p></li><li><p>Flags</p></li><li><p>校验和</p></li></ul></li><li><p>数据</p></li></ul><img src="'+C+'"><ul><li><p>Sequence Number</p></li><li><p>Acknowledgment Number</p></li></ul><p>描述我们的订单号，用来唯一表示 HTTP 报文的，ack 还用来确认报文，来保证数据的可达性</p><h3 id="常用选项" tabindex="-1">常用选项 <a class="header-anchor" href="#常用选项" aria-hidden="true">#</a></h3><img src="'+T+`"><h2 id="如何使用-tcpdump" tabindex="-1">如何使用 tcpdump <a class="header-anchor" href="#如何使用-tcpdump" aria-hidden="true">#</a></h2><h3 id="捕获及停止条件" tabindex="-1">捕获及停止条件 <a class="header-anchor" href="#捕获及停止条件" aria-hidden="true">#</a></h3><ul><li><p>-D列举所有网卡设备</p></li><li><p>-i选择网卡设备</p></li><li><p>-C抓取多少条报文</p></li><li><p>--time-stamp-precision 指定捕获时的时间精度，默认毫秒 micro, 可选纳秒 nano</p></li><li><p>-S 指定每条报文的最大字节数，默认 262144 字节</p></li></ul><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">tcpdump</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-D</span></span>
<span class="line"></span></code></pre></div><p>抓取 2 条网络报文，并设置时间精度</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">tcpdump </span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">i 网卡设备 </span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">c </span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">--</span><span style="color:#A6ACCD;">time</span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">stamp</span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">precision nano</span></span>
<span class="line"></span></code></pre></div>`,60),b=[_];function k(I,v,f,A,x,D){return e(),i("div",null,b)}const S=l(m,[["render",k]]);export{F as __pageData,S as default};
